<!DOCTYPE>
<html>
	<head>
		<meta charset='utf-8'>
		<link href='css/bootstrap.min.css' rel='stylesheet'>
		<link href='css/amelin/bootstrap.min.css' rel='stylesheet'>
		<link href='css/font-awesome.min.css' rel='stylesheet'>
		<link href='css/style.css' rel='stylesheet'>
		<script src='js/bootstrap.min.js'></script>
		<script src='js/jquery-2.1.1.min.js'></script>

		<title>Reiknirits lokapróf...</title>
	</head>
	<body>
		<div id='date'>
Thu Nov 13 13:05:41 GMT 2014
		</div>
		<div class='letter'>
<h1 id="reikniritsglosur">Reikniritsglosur</h1>
<h3 id="listi-yfir-shit-að-læra-fyrir-prófið">Listi yfir shit að læra fyrir prófið</h3>
<ol style="list-style-type: decimal">
<li><em>64-bit cost module</em>'ið úr bókinni og glærum</li>
<li>Æfa sig í að sjá út hvaða sort algorithma er verið að nota</li>
<li>Hver er tímaflækja þeirra og afhverju</li>
<li>FKN allt í sambandi við þessi helvítis <em>Red-Black BST</em>
<ul>
<li>Sennilega fínt að læra almennt allt í sambandi við <em>BST</em></li>
</ul></li>
<li>Spurning með <em>hashtables</em></li>
<li>Formúluna sem tekur N og tíma og svo áttu að geta séð hvað corrolationið er</li>
<li><em>Order of growth for the running time</em> fyrir allskonar for lykkjur</li>
<li><em>Graph Search</em>
<ul>
<li>kunna öll search, <strong>pre-order</strong>, <strong>postorder</strong> o.s.fr.</li>
<li>distTo[] and edgeTo[]</li>
<li><strong>priority queue</strong></li>
</ul></li>
<li><em>Ternaru search trees</em></li>
<li><em>Binary Heap</em></li>
<li><em>KD-Trees</em></li>
</ol>
<h4 id="þarf-að-athuga-með">Þarf að athuga með:</h4>
<ul>
<li>Knuth-Morris-Pratt</li>
<li>Boyer-Moore</li>
</ul>
<h3 id="ent-æfingar">ENT ÆFINGAR</h3>
<ul>
<li>Union Find †</li>
<li>Order of Growth and Simple sorting algorithms †</li>
<li>Advanced sorting algorithms †</li>
<li>Merge sort - fixed †</li>
<li>Hrúgur †</li>
<li>Binary Search Tree †</li>
<li>Kd trees †</li>
<li>Red-Black trees, DFS and BFS <strong>FOKK HVAÐ ÉG SKIL ÞENNAN VIÐBJÓÐ ENÞÁ EKKI!!</strong></li>
<li>Directed Graphs</li>
<li>MST and Shortest Path problems</li>
<li>Dynamic Optimization and Satisfiability</li>
</ul>
<h3 id="tímaflækja">Tímaflækja</h3>
<p>tvenns konar. Áætluð tímaflækja út frá kóða og hin, mæld tímaflækja. Hægt að plotta upp á grafi. þÁ sjáum við grafið sem tímaflækju</p>
<pre><code>int sum = 0;
for (int i = 0; i &lt; n; i++0
  for(int j = 1; j &lt; n; j = j*2)
    sum = sum + i * j;</code></pre>
<p><strong>svar: T(n) ~n lg n</strong></p>
<h4 id="kvótaröð-verður-ekki-til-prófs">Kvótaröð verður ekki til prófs</h4>
<h3 id="union-find">Union Find</h3>
<h4 id="quick-find">Quick Find</h4>
<p>Fyrir Quick Find á Ent að þá þýðir 0-6 að öll gildi sem eru eins og það sem er í sæti 0, taka gildi sem eru eins og það sem er í staki 6. Þannig endar það union fylki mjög eins. <br> <strong>P-Q</strong> <em>Öll P breytast í Q</em></p>
<h4 id="quick-union">Quick Union</h4>
<p>Fyrir Quick Union á ENT að þá þýðir 0-6 að það tré, í heild sinni, sem 0 tilheyrir fer undir það tré sem 6 tilheyrir. Þannig endar union fylkið með mjög fjölbreytt, ef tala er jöfn sætanúmerinu sínu, er hún rót.<br> <strong>P-Q</strong> <em>Rótin af laufinu P fer undir rótina af laufinu Q</em></p>
<h4 id="weighted-quick-union">Weighted Quick Union</h4>
<p>Fyrir wighted quick union á ENT að þá þýðir 0-6 að það tré, í heild sinni, sem 0 tilheyrir fer undir það tré sem 6 tilheyrir <strong>EF</strong> að tréið sem 0 tilheyrir er minna en tréið sem 6 tilheyrir. Ef tréið sem 6 tilheyrir er minna eða jafn stórt tréiinu sem 0 tilheurur, þá fer tréið sem 6 tilheyrir undir rótina af tréinu sem 0 tilheyrir<br> <strong>p-q</strong>, <strong>P</strong> = <em>rótin sem <strong>p</strong> tileyrir</em>, <strong>Q</strong> = <em>rótin sem <strong>q</strong> tilheyrir</em></p>
<ul>
<li><strong>P &lt; Q</strong> - <em>P undir Q</em></li>
<li><strong>P &gt;= Q</strong> - <em>Q undir P</em></li>
</ul>
<h3 id="skoðum-wqupc">Skoðum <strong>WQUPC</strong></h3>
<table>
<thead>
<tr class="header">
<th align="left">algortihm</th>
<th align="right">worst case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">quick-find</td>
<td align="right">M N</td>
</tr>
<tr class="even">
<td align="left">quick-union</td>
<td align="right">M N</td>
</tr>
<tr class="odd">
<td align="left">weighted QU</td>
<td align="right">N + M log N</td>
</tr>
<tr class="even">
<td align="left">QU+Path Comp.</td>
<td align="right">N + M log N</td>
</tr>
<tr class="odd">
<td align="left">WQU+PathComp</td>
<td align="right">N + M lg* N</td>
</tr>
</tbody>
</table>
<p><em>Fyrir N hluti og M aðgerðir</em></p>
<h3 id="order-of-growth">Order of growth</h3>
<p>Þegar mapur er að leita að hver er með minnsta order of growth og shit að þá er gott að sitja bara milljón inn fyrir N. Það hjálpar mér allavega að sjá fyrir mér betur hver er stærstur og hver er minnstur.</p>
<p>Algengar tímaflækjur sem maður ætti að átta sig á</p>
<ul>
<li>1</li>
<li>log N</li>
<li>N</li>
<li>N log N</li>
<li>N<sup>2</sup></li>
<li>N<sup>3</sup></li>
<li>2<sup>N</sup></li>
</ul>
<p><strong>Formúla til að finna tímaflækjur ef maður er með tímatökur og stakafjölda.</strong> <br></p>
<p>2.1s = 1000 16.8 = 2000</p>
<p>Formúlan T(n) = a * n<sup>b</sup> <br> b = log_2 t_2 - log_2 t_1   log_2 n_2 - <em>2 n</em>1 <br> a = t / n<sup>b</sup> <br> b = 3 <br> a = 2.1 * 10<sup>-9</sup> <br></p>
<p>svar = ~ 2.1 * 10<sup>-9</sup> * n<sup>3</sup></p>
<!--
#### Þetta er sennilega Bog O notation

|   sort algorithm      |   Worst Case      |   Average Case                    |
|   ------------------- |   :-------------: |   ------------------------------: |
|   Selection Sort      |   N<sup>2</sup>   |   N<sup>2</sup>                   |
|   Bubble Sort         |   N<sup>2</sup>   |   N<sup>2</sup>                   |
|   Insertion Sort      |   N<sup>2</sup>   |   N<sup>2</sup>                   |
|   Mergesort           |   N * log N       |   N * log N<sup>2</sup>           |
|   Quicksort           |   N<sup>2</sup>   |   N * log N<sup>2</sup>           |
|   Radix               |   N               |   N                               |
|   Treesort            |   N<sup>2</sup>   |   N * log N<sup>2</sup>           |
|   Heapsort            |   N * log N       |   N * log N                       |


#### Þetta er úr bókinni ---- Á EFTIR AÐ UUPÆRA

|   sort algorithm      |   Worst Case      |   Average Case                    |   Best case                   |
|   ------------------- |   :-------------: |   :-----------------------------: |   --------------------------: |
|   Selection Sort      |   Altaf eins      |   N<sup>2</sup>/2 + N             |   Altaf eins                  |
|   Bubble Sort         |   N<sup>2</sup>   |   N<sup>2</sup>                   |
|   Insertion Sort      |   N<sup>2</sup>   |   N<sup>2</sup>                   |
|   Mergesort           |   N * log N       |   N * log N<sup>2</sup>           |
|   Quicksort           |   N<sup>2</sup>   |   N * log N<sup>2</sup>           |
|   Radix               |   N               |   N                               |
|   Treesort            |   N<sup>2</sup>   |   N * log N<sup>2</sup>           |
|   Heapsort            |   N * log N       |   N * log N                       |
-->

<h4 id="aðeins-um-sort-algorithmana">Aðeins um sort algorithmana</h4>
<ul>
<li><strong>Selection Sort</strong>
<ul>
<li>Finnur minnsta stakið</li>
<li>Víxlar því við fremstastakið</li>
<li><em>Finnur svo næst minsta og setur það næst fremst, og svo koll af kolli.</em></li>
<li><strong>Altaf sama flækjustig</strong> <!-- * *Byrjar á því að finna minnsta stakið og skiptir fremsta stakinu út fyrir það.* --> <!-- *  *Svo finnur það næst-minnsta og skiptir næst-fremsta út fyrir það* --></li>
</ul></li>
<li><strong>Insertion Sort</strong> <!--
    * Finnur minnsta stakið
    * Geymir það og færir öll stökin frá og fyrsta, að stakinu vinstra megin við vinstra
    * Til hægri, þannig fyrsta slottið er tómt og setur svo minnsta stakið í það
    * *Er svona svipað eins og þegar maður er að raða spilum á hendi.*
    * *Gerir þetta svo koll af kolli endurkvæmt eins og í Selection Sort, finnur næstminsta, setur næstfremst*
    * **Average er flækjustigið N<sup>2</sup>/4 samanburðir + N<sup>2</sup>/4 skiptingar**
    * **Versta tilfelli er það N<sup>2</sup>/2 samanburðir + N<sup>2</sup>/2 skiptingar**
    * **Besta tilfelli er það N, með 1 samanburði og 0 skiptingum**
-->
<ul>
<li>Skoðar stak og ber það við stök fyrir neðan sig. Byrjar á fyrsta stakinu og vinnur sig upp</li>
<li>Þegar það finnur réttan stað til að troða inn að þá færir það allt draslið til hægri svo það sé pláss</li>
<li>Athuga að á ENT að þá er ekki geymt gildi í tmp og allt draslið shiftað, heldur swappast eitt og eitt niður</li>
</ul></li>
<li><strong>Shell Sort</strong>
<ul>
<li>Finnur svakalega svipað og Insertion Sort nema að það brýtur dralsið niður í parta eða eð</li>
<li>Tekur fyrir eð stak sem er h langt frá fyrsta stakinu</li>
<li>Ber þau saman og víxlar ef þarf</li>
<li>Færir sig svo einu staki til hægri og gerir svo það sama alveg þangað til það er komið út á enda</li>
<li>*Þá minnkar það h og fer aftur í gegnum fylkið af stökum á sama hátt og það gerði áður</li>
</ul></li>
<li><strong>Merge Sort</strong>
<ul>
<li>Vinnur mjög endurkvæmt eftir þessum reglum</li>
<li><em>Tekur lista og splittar honum í tvennt, splittar aftur í tvennt, þangað til það er ekki hægt að splitta meira</em></li>
<li><em>Tekur parar saman 2 og 2</em></li>
<li><em>Býrð til nýjan lista úr stökunum úr 2 litlum, semsagt 2 tveggja staka verða að einum 4 staka</em></li>
<li><em>Raðar í listan með því að bera saman fremstu stökin í þessum 2 litlum, það minna af þeim 2 fer fremst</em></li>
<li><strong>Tímaflækja fyrir lista D af N mörgum stökum sem uppfyllir D(N) = 2 D(N/2) + N fyrir N &gt; 1</strong></li>
<li><strong>Er D(N) = N lg N</strong></li>
<li>Þar sem ég geri ráð fyrir því að skiptingin sé lg N og við berum saman N sinnum.</li>
</ul></li>
<li><strong>Quick Sort</strong>
<ul>
<li><em>Áður en við framkvæmum QuickSort að þá stokkum við.</em></li>
<li><strong>Tímaflæka er í versta falli N<sup>2</sup></strong></li>
<li><strong>Tímaflækja í besta falli, það gerist þegar splittið nkvl til helminga, N ln N</strong></li>
<li><strong>Tímaflækja almennt 2N ln N</strong></li>
<li><em>40% fleiri samanburðir heldur en í merge sort, en tekur aftur á móti mun minna minni.</em></li>
<li>Er búinn að sjá nokkrar mismunandi útfærslur af þessu.. Veit ekkert hvað er réttast.</li>
<li>Bókin er er ekkert frábær í að útskýra þetta en Sesame Street cs50 útskýrir aðeins betur</li>
<li><em>Þar taka þau stakið lengst til hægri sem veltistak og er um vegg sem færist á milli aðgerða</em></li>
<li><em>Ef að stak er meira en veltistak að þá fær það að vera</em></li>
<li><em>Ef stak er minna þá skiptum við því út með stakinu vinstra meginn við veggin og færum veggin um einn</em></li>
<li><em>Gerum þetta þangað til við komum að veltistakinu, skiptum á því og stakinu hægra megin við vegginn og færum vegginn um einn.</em></li>
</ul></li>
<li><strong>Heap Sort</strong>
<ul>
<li><em>Við horfum á fylki sem tré, 0 er foreldri 1 og 2, 1 er foreldri 3 og 4, 2 er foreldri 5 og 6 og svo framvegis</em></li>
<li><em>Þegar við bætum við staki að þá lengjum við fylkið okkar um einn, setjum stakið aftast, og berum það svo við foreldri</em></li>
<li><em>Ef forledrið er minna, að þá víxlum við þessum. Svo berum við nýja foreldrið, við forledrið fyrir ofan það o.s.fr.</em></li>
<li><em>Þegar við fjarlægjum stak að þá setjum við aftasta stakið í staðinn og minnkum fylkið um einn</em></li>
<li><em>Svo skoðum við nokkuð stakið á nýja staðnum sé minna en barnið sitt, ef svo er að þá sökkvum við því</em></li>
<li><strong>Insert and Swim, Remove and Sink</strong></li>
<li><strong>Tímaflækjan er log N</strong></li>
</ul></li>
</ul>
<h4 id="meira-um-sort-algorithmana">Meira um sort algorithmana</h4>
<table>
<thead>
<tr class="header">
<th align="left">algorithm</th>
<th align="center">stable</th>
<th align="center">in place</th>
<th align="center">running time</th>
<th align="right">Extra space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">selection sort</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">N<sup>2</sup></td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">insertion sort</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">N &lt;-&gt; N<sup>2</sup></td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="left">shell sort</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">N log N ?</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">quicksort</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">N log N</td>
<td align="right">lg N</td>
</tr>
<tr class="odd">
<td align="left">3-way quicksort</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">N &lt;-&gt; N log N</td>
<td align="right">lg N</td>
</tr>
<tr class="even">
<td align="left">mergesort</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">N log N</td>
<td align="right">N</td>
</tr>
<tr class="odd">
<td align="left">heapsort</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">N log N</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<h3 id="memoriesall-alone-in-the-moonlight">Memories<sup>all alone in the moonlight</sup></h3>
<p>Þó svo java sé agalega þægilegt þegar það kemur að minni, að þá er samt súper mikilvægt að vita hversu mikið minni java notar.</p>
<table>
<thead>
<tr class="header">
<th align="right">Wat?</th>
<th align="center">memories</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">boolean</td>
<td align="center">1 byte</td>
</tr>
<tr class="even">
<td align="right">char</td>
<td align="center">2 bytes</td>
</tr>
<tr class="odd">
<td align="right">int</td>
<td align="center">4 bytes</td>
</tr>
<tr class="even">
<td align="right">double</td>
<td align="center">8 bytes</td>
</tr>
</tbody>
</table>
<p>Og shit sem eg nota aldrei</p>
<table>
<thead>
<tr class="header">
<th align="right">shit</th>
<th align="right">memories</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">byte</td>
<td align="right">1 byte</td>
</tr>
<tr class="even">
<td align="right">float</td>
<td align="right">4 bytes</td>
</tr>
<tr class="odd">
<td align="right">long</td>
<td align="right">8 bytes</td>
</tr>
</tbody>
</table>
<p><em>String</em> er <strong>Object</strong> eins og <em>Array</em> og <em>Linked List</em>.</p>
<p><strong>Object</strong> eru altaf með 16 bytes í overhead. Það er 8 fyrir reference og rest fyrir garbage collection upplýsingar og annað. þannig að:</p>
<ul>
<li><strong>16 bytes</strong> í overhead</li>
<li><strong>NX bytes</strong> fyrir N mörg eintök af týpunni X</li>
<li><strong>ROUND UP</strong>: leggur saman allt dótið og bætir við bytes þannig að það sé hægt að deila með 8</li>
</ul>
<h3 id="binary-search-tree">Binary Search Tree</h3>
<p><em>Venjulegt search</em> fer til vinstri ef það er minna en nóðan sem það er statt í og hægri ef það er meira en nóðan sem það er statt í.</p>
<h4 id="preorder">preorder</h4>
<p>Ferð í gegnum allt tréið, lengst til vinstri fyrst, en skrifar út um leið og nóða er heimsótt</p>
<pre><code>    private void preorder(Node tit) {
        if(tit != null) {
            System.out.print(tit.data + &quot; &quot;);
            preorder(tit.left);
            preorder(tit.right);
        }
    }</code></pre>
<div class="figure">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png" alt="preorder" /><p class="caption">preorder</p>
</div>
<h4 id="inorder">inorder</h4>
<p>Er basicly að kunna stafrófið.. Og þegar ég segi kunna, að þá meina ég að hafa það cheat sheetinu.</p>
<pre><code>    private void inorder(Node tit) {
        if(tit != null) {
            inorder(tit.left);
            System.out.print(tit.data + &quot; &quot;);
            inorder(tit.right);
        }
    }</code></pre>
<div class="figure">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png" alt="inorder" /><p class="caption">inorder</p>
</div>
<h4 id="postorder">postorder</h4>
<p>Þá fer maður eins langt niður til vinstri eins og hægt er, skrifar það út, bakkar um einn og reynir að komast lengst til vinstri aftur, þegar það er búið að fara lengst til vinstri að þá er í lagi að skrifa út nóðuna sem maður fer tilbaka</p>
<pre><code>    private void postorder(Node tit) {
        if(tit != null) {
            postorder(tit.left);
            postorder(tit.right);
            System.out.print(tit.data + &quot; &quot;);
        }
    }</code></pre>
<div class="figure">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png" alt="postorder" /><p class="caption">postorder</p>
</div>
<h3 id="kd-tree">KD-Tree</h3>
<p>Þegar punkti er bætt í KD-Tree myndar hann svona línu sem afmarkar svæði. Hvort línan sé lárétt eða lóðrétt, fer allt eftir parent punkti.. þúst, hvort hann fékk lárétta eða lóðrétta línu.</p>
		</div>
	</body>
</html>
